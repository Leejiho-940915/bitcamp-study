#  10일차 수업내용(2021-07-09.금)

### *배열(array)

- 같은 종류와크기(data type)를 가진 메모리를 여러개(연속된 메모리) 선언하는 문법

```java
int[] arr = new int[3];
// int[]     ---   배열타입을 가리킨다
// arr       ---   배열의 주소를 저장하는 변수{"레퍼런스"(reference)}
// new       ---   메모리 준비 명령
// int[3];   ---   data type[개수];
```



### *배열(array)과 메모리   =  인스턴스와 레퍼런스

```java
int[] arr = new int[3];   
arr = 200;  /*이라고 예시*/
// int[]  배열 인스턴스의 주소를 담을 변수 = "레퍼런스(reference)"
// arr    200
// int[3];  연속된 int 메모리 준비 = "인스턴스(instance)"
// 아래 표를 보고 확인해보자
```

| arr = 200 | int  | int  | int  |
| --------: | :--: | :--: | :--: |
|           |      |      |      |
|           |      |      |      |
|           |      |      |      |
|           |      |      |      |
|           |      |      |      |

- 변수를가리키는 번호를 index라고한다.
- 연속된 메모리 준비 = 배열의 **인스턴스(instance)**라고한다 
- 배열의 주소를 담은 변수 = 래퍼런스(reference) 라고한다.
- **메모리의 시작전에서 떨어져있는 위치 = "offset" 오프셋 주소**
  - 시작점은0부터시작
  - Application 이 할당 받은 메모리의 시작점을 0으로 하여 계산된 주소
- 정수는 4바이트 크기를 많이쓰고
- 부동소수점은 8바이트크기를  많이쓴다.
- 유니코드는2바이트를사용 utf-16
- char c;



### *배열레퍼런스와 인스턴스

주소를잃어버려 사용할 수 없는 메모리 = Garbage

래퍼런스에 그 래퍼런스 타입의 배열 주소를 넘겨야 한다.

null = 특정 인스턴스의 주소를 담고 있지 않음을 선언한다.

널포인터에러가나오면 배열의 주소를 벗어난것이다.

#### 자바의 변수 종류

primitive data type 변수타입 빼고는 나머지 다 주소변수다!!

String  문자열도 주소변수이다.

주소변수: 레퍼런스  

가비지컬랙터는 할당메모리가 부족할때 실행된다.

자바 정적타입바인딩

자바스크립 동적타입바인딩

명시적형변환은 안짤린다고 확신이 들때만 해야한다.ex04 -900번대 참조

#### 상수

- 변수의 값을 고정하는 방법
- 변수는 언제든지 값을 변경하루있다. 단 상수는 값을 오직한번만 저장 가능하다.
- 문법으로는 변수앞에 final 을 붙이면 된다.
- 예)  final int b;  b=100
- 상수인 경우 이름을 보통 모두 대문자로 작성한다.
- 변수를 선언하는 문장에서 바로 값을 초기화시킨다.



### *변수의 종류 (ex04-Exam0710참조)

```java
public class Exam0710 {
  
  int a; // 인스턴스 변수
  
  static int b; // 클래스 변수

  
  public static void main(String[] args/*로컬변수=파라미터*/) {
    
    int c; // 로컬 변수
    
  }
}

// 인스턴스 변수(instance variable)
// - new 명령을 사용하여 인스턴스를 생성할 때 준비되는 변수
//
// 클래스 변수(class variable = static variable)
// - 클래스가 로딩될 때 준비되는 변수
//
// 로컬 변수(local variable)
// - 블록을 실행할 때 준비되는 변수
//
// 파라미터(parameter)
// - 메서드의 아규먼트를 받는 로컬 변수이다.
//   예) 위의 코드에서 main()의 args 로컬 변수
```

- static 이 붙은 블록(스태틱 메서드=클래스 메서드)에서는 그 블록 바깥 쪽에있는 스태틱 변수(클래스 변수)를 사용할 수 있다.
- static 붙지 않은 인스턴스 변수는 사용할 수 없다

- static 이 붙지 않은 블록(인스턴스 블록)에서는 그 블록 바깥 쪽에 선언된 변수를 모두 접근할 수 있다.



##### 같은 블록에서는 중복 선언 불가!!

```java
public class Exam0810 {

  int a; // 인스턴스 변수

  static int b; // 클래스 변수

  // 클래스 블록 안에 선언된 변수는 종류에 상관없이 중복 선언 불가!
  //int a; // 컴파일 오류!
  //static int a; // 컴파일 오류!
  //int b; // 컴파일 오류!
  //static int b;  // 컴파일 오류!

  public static void main(String[] args/*로컬변수=파라미터*/) {
    // 그러나 메서스 블록에서는 클래스에 선언된 변수의 이름과 
    // 같은 변수를 선언할 수 있다.
    // 왜? 영역이 다르니까!
    int a;
    int b;

    // 마찬가지로 이 블록 안에서는 같은 이름의 변수를 만들 수 없다.
    //String a; // 컴파일 오류! 데이터 타입에 상관없이 이름 중복 불가!
  }

  public static void m2() {
    // 여기에 선언된 변수는 main() 블록에 선언된 변수와 다른 변수이다.
    int a;
    int b;
  }
}
```



## *자바의 변수 종류

` #primitive data type 변수 `

```java
정수 값 저장변수
- byte b;
- short s;
- int i;
- long l;
부동소수점 값 저장변수
- float f;
- double d;
논리 값 저장 변수
- boolean bool;
유니코드 저장 변수
- char c;

```

> 그외 모든 주소 변수 를 래퍼런스 라고 한다.(배열 레퍼런스 포함)
>
> String 도 주소 변수라고 할수있다. 데이타 타입 변수가 아니다!



## *연산자(operator)

#### 산술 연산자ex05 110

#### `  산술연산자 우선순위 ` 

1.   ()   괄호가 제일먼저 계산된다.
2.   ++,--  증감연산자가 그다음계산한다.
3.  /,*,%   나누기,곱하기,퍼센트 가 그다음 계산된다.
4.  +, -   더하기 빼기 계산된다.
5.  = 



#### ! 같은순위에 산술인경우 제일 앞에부터 계산된다!.

숫자의 크기에 상관없이 작은 숫자를 다루더라도 
//   정수를 다룰 때는 그냥 int를 사용하라!



#### static type binding  VS  dynamic type binding 

``` java
int i; 
i = 100;
//라고  변수의 타입이 주어졌을때
// 자바는 변수의 타입이 한번 정해지면 변경되지 않는다.
i = 3.14f // 컴파일 오류!
i = true; // 마찬가지로 안된다.
i = "hello"; //타입이 변경되지 않는다.
// 단! 자바 스크립트는 가능하다
자바스크립트는 변수에 값을 저장하는 순간 데이터 타입이 결정되고 변경할수있다.
```



### 형변환(type casting=type conversion)?

- 변수나 리터럴을 다른 타입의 값을 바꾸는 것
- 원래 변수의 타입을 바꾸는것이 아니다!
- 내부적으로는 변수에 들어있는 값을 꺼내 지정된 타입의 임시 메모리를 만들어 저장한다.



### 암시적 형변환

- 자바의 최소 연산 단위는 int 이다.
- int 보다 작은 크기의 메모리 값을 다룰 때 내부적으로 int 로 자동 형변환을 수행한 다음에 연산을 수행한다.
- 내부적으로 자동 형변환하는 것을 "**암시적 형변환(implicit type conversion)**"이라 부른다.

`byte + byte = int ` ` short + short = int` ` byte + short = int` 

` int + int = int ` 

` long + long = long `

 ` float + float = float `

 ` double + double = double ` 

- 연산은 항상 같은 타입끼리만 가능하다!
- 다른 타입끼리 연산을 할 때는 둘 중 한개의 타입을 다른 타입으로 바꿔야 한다.
- 암시적 형변환 규칙
  - 다음과 같이 오른쪽 타입의 값으로 자동 변환시킨다.
  - ` byte,short,char => int => long => float => double `
- 정수와 부동소수점에 대해서만 암시적 형변환이 일어난다.
- 그외 다른 타입은 불가능하다!



### 명시적 형변환

``` java
 public static void main(String[] args) {

    byte b;

    // 4바이트 크기를 갖는 정수 리터럴을 byte 변수에 저장할 수 없다.
    //    b = 259; // 컴파일 오류!

    // 저장하고 싶다면 형변환(type casting)을 명시적으로 지정하라!
    // => 단 메모리에 들어가기에 큰 값이라면 형변환할 때 값이 잘린다.
    b = (byte)259;
    // int(4 byte)  => 0000 0000 0000 0000 0000 0001 0000 0011
    // byte(1 byte) => ---- ---- ---- ---- ---- ---- 0000 0011
    //
    // => 4바이트 중에서 앞의 3바이트가 잘리고 뒤의 1바이트만 b에 저장된다.
    // 
    System.out.println(b); // 3

    // 결론!
    // => 큰 메모리의 값을 작은 메모리에 넣으려고 형변환을 사용하기도 하는데
    //    다만 형변환하더라도(즉 작은 메모리에 넣더라도) 값이 잘리지 않을 때만 하라!
    // => 형변환하더라도 값이 소실되지 않을 때만 "명시적 형변환"을 지시하라!
  }
```



### 관계 연산자(relational operators)

- `  <  `  좌변 값이 작으면 true 아니면 false
- `  <= `    좌변 값이 작거나 같으면 true 아니면 false
- `   >  ` 좌변 값이 크면 true 아니면 false
-  `    >= ` 좌변 값이 크거나 같으면 true 아니면 false



### 등위연산자(equality oprators)

- ` == `두 값이 **같으면** true 아니면 false
- ` != `두 값이 **다르면** true 아니면 false



### 논리 연산자

- ` && `   ` & `

  - AND 연산자
  - 두 개의 논리 값이 모두 true 일 때 결과가 true가 된다.

  ``` java
  System.out.println(true && true); // 결과는 true
  System.out.println(true && false); // 결과는 false
  System.out.println(false && true); // 결과는 false
  System.out.println(false && false); // 결과는 false

  ```

  - ` && ` ` || `와 ` & ` ` | ` 의 **계산순서**

  - ``` java
    &&,||
    앞의 피연산자의 값으로 결과를 알 수 있다면 뒤의 명령은 실행하지않는다.
    &&,||  AND연산자, OR연산자 둘다 같은 계산 순서.
     boolean a = false;
     boolean b = false;
     boolean r = a && (b = true); 
    // - && 연산에서 왼쪽 값이 이미 false이기 때문에 결과는 확정되었다.
    // - 따라서 오른쪽값을 실행하지 않는다.
    // - 이렇게 && 연산의 오른쪽을 실행하기 전에 결과를 알 수 있다면 
    //   JVM은 실행의 효율을 위해 && 연산의 오른쪽을 실행하지 않는다.
    ```

  - ``` java
    &,|
    앞의 피연산자로 결과를 알 수 있을 지라도, 뒤에 놓은 명령 까지 모두 실행한다.
    &,| AND연산자, OR연산자 둘다 같은 계산순서.
     a = false;
     b = false;
     r = a & (b = true);
    // & 연산자의 경우 왼쪽 값으로 결과를 예측할 수 있다 하더라도,
    //   결과에 상관없이 & 오른쪽 문장을 무조건 실행한다.
    ```

  - ​

- ` || `   ` | `

  - OR 연산자
  - 두 개의 논리 값 중 한 개라도 true이면 결과는 true가 된다.

  ``` java
  System.out.println(true || true); // 결과는 true
  System.out.println(false || false); // 결과는 false
  ```

  ​

- ` ! `

  - NOT연산자
  - true는 false로  false는 true로 바꾼다.

  ``` java
  System.out.println(!true); // 결과는 false
  System.out.println(!false); // 결과는 true
  ```

  ​

- ` ^ `

  - exclusive-OR(XOR)연산자
  - 배타적 비교 연산자라 부른다
  - 두 개의 값이 다를 때 true이다.

  ``` java
  System.out.println(true ^ true); // 결과는 false
  System.out.println(true ^ false); // 결과는 true
  ```

- ### 조건문과 비트 연산

  - &&, ||, ! 의 피연산자(operand)는 반드시 boolean 이어야 한다.		

    - ``` java
      boolean r;
          //r = 10 && 20; // 컴파일 오류!
          //r = 10 || 20; // 컴파일 오류!
      ```

  - &, |, ^, ~(not) 의 피연산자는 정수이어야 한다.

    - ``` java
      int r2 = 10 & 20; // OK!    
          //float r3 = 10.2f & 20.3f; // 컴파일 오류!
      ```

### 비트 연산자(&, |, ^, ~)

- 정수 값에 대해서는 **` && `**와 `  ||  ` 와` ! ` 을 **사용할 수 없다.**
- 그러나 ` & ` 와 ` | ` 와 ` ~ ` 는 **사용할 수 있다.**
  - 각 비트 단위로 연산을 수행한다.
  - 1은 true, 0은 false 라고 간주하고 계산한다.
  - 출력 결과도 정수이다.
- 비트연산자는 이미지 및 영상 처리에 사용된다.
  - 마스킹, 오버레이 기법에 사용된다.
  - 색조 변경에 사용된다.
- ex05-Exam0350 참조



### 조건 연산자  ` ? ` ` : ` 

조건 ? 표현식1 : 표현식2

- 표현식1 --- 참일때 실행
- 표현식2 --- 거짓일때 실행

``` java
  // 조건연산자
    // => 조건 ? 표현식1 : 표현식2
    // => 조건이 참이면 표현식1을 실행하고,
    //    조건이 거짓이면 표현식2를 실행한다.
    int age = 20;

    // 조건 연산자는 할당 연산자(=)의 왼편에 변수를 선언해야 한다.
    // => 선언하지 않으면 문법 오류!
    //    (age > 18) ? System.out.println("성인이다.") : System.out.println("미성년자이다.");

    // 조건 연산자의 결과 값이 왼편의 변수 타입과 일치해야 한다.
    // => 결과 값이 없거나 타입이 일치하지 않으면 문법 오류!
    //String str = (age > 18) ? System.out.println("성인이다.") : System.out.println("미성년자이다.");

    // 표현식 자리에는 문자가 되었든 숫자가 되었든 
    // 실행 결과가 놓여져야 한다.
    // 위의 System.out.println(...) 문장은 결과를 리턴하지 않는다.
    // 그래서 컴파일 오류이다.

    String message = (age > 18) ? "성년" : "미성년";
    System.out.printf("나이 %d는(은) %s이다.\n", age, message);
```

- 표현식(expression) ?
  - 작업을 수행한 후 결과를 리턴하는 문장이다.
- 문장(statement) ?
  - 작업을 수행시키는 명령이다.
- 문장과 표현식의 관계
  - statement 중에서 결과를 리턴하는 statement를 expression이라 부른다.



### *증감 연산자 : 전위(prefix) / 후위(postfix)

#### ` 전위연산자 `

``` java
int i = 100; //이라고 변수메모리에 값을 저장했다.
++i; //전위연산자는 컴파일할때 다음 문장으로 변환된다.
i = i + 1  //과같다고 볼수있다.
```

#### ` 후위연산자 `

``` java
int i = 100;      //- 이라고 변수메모리에 값을 저장했다
i++;              //- 후위연산자는 컴파일할때 다음 문장으로 변환된다.
(temp = i;   	  //- temp라는 임시변수안에 현재 i 값을 저장하고
i = i + 1;) 	  //- 그다음 1을 증가시킨다.
System.out.println(i);   // 101
//- 따라서 후위연산자는 컴파일할때는 임시변수안에있는 값을 불러오고
System.out.println(i++); // 101
//- 그다음 값이 증가된 값을 나타난다. 현재 i = 102 가 되어있다.
System.out.println(i);   // 102
```





### 비트 이동 연산자

` >> ` , ` >>> ` , ` << ` 

``` java
 public static void main(String[] args) {
    // << 비트 이동 연산자 사용법
    // - 왼쪽으로 비트를 이동시킨다.
    // - 오른 쪽 빈자리는 0으로 채운다.
    // - 왼쪽 경계를 넘어간 비트는 자른다.
    //
    int i = 1;
    //      [00000000000000000000000000000001] = 1

    System.out.println(i << 1);
    //     0[0000000000000000000000000000001 ]
    //      [00000000000000000000000000000010] = 2

    System.out.println(i << 2);
    //    00[000000000000000000000000000001  ]
    //      [00000000000000000000000000000100] = 4

    System.out.println(i << 3);
    //   000[00000000000000000000000000001   ]
    //      [00000000000000000000000000001000] = 8

    System.out.println(i << 4);
    //  0000[0000000000000000000000000001    ]
    //      [00000000000000000000000000010000] = 16

    i = 11; // [00000000000000000000000000001011]
    System.out.println(i << 1); //   0[00000000000000000000000000010110] => 22
    System.out.println(i << 2); //  00[00000000000000000000000000101100] => 44
    System.out.println(i << 3); // 000[00000000000000000000000001011000] => 88

    // 왼쪽 이동
    // - 1비트 이동은 곱하기 2 한 것과 같은 효과를 준다.
    // - 값을 배수로 증가시킬 때 곱하기 연산을 하는 것 보다
    //   왼쪽 비트 이동 연산을 하는 것이 빠르기 때문에
    //   실무에서는 이 비트 이동 연산을 자주 사용한다.
    // - 비트 이동 => '2**이동비트'를 곱한 것과 같은 결과를 만든다.
  }
}
```



### 관계연산자 : 부동소수점 비교

- 부동소수점 값을 연산할 때 IEEE 754 명세에 따라 작업을 수행한다.
- 그과정에서 값의 왜곡이 발생할 수 있다.

``` java
 public static void main(String[] args) {
    double d1 = 987.6543;
    double d2 = 1.111111;
    System.out.println((d1 + d2) == 988.765411);
    // 결과는 false이다.
    // 이유?
    // - 부동소수점 값을 연산할 때 IEEE 754 명세에 따라 
    //   작업을 수행한다. 그 과정에 값의 왜곡이 발생할 수 있다.
    // - CPU나 OS, JVM의 문제가 아니다.
    // - IEEE 754 명세에 따라 부동소수점을 처리하는 모든 
    //   컴퓨터에서 발생하는 문제이다.
    System.out.println(d1);
    System.out.println(d2);
    System.out.println(d1 + d2); 
    // 987.6543 + 1.111111 = 988.7654110000001
    // => 결과 뒤에 극소수의 값이 붙는다.
    // => 그래서 부동 소수점의 비교를 대충 다루지 말라!
    // 0 10000001000 1110110111010011110000000001101000110110111000101111 (987.6543)
    // 0 01111111111 0001110001110001110001010011111100111001110100011011 (1.111111)
    //
    // 1.1110110111010011110000000001101000110110111000101111
    // 0.0000000010001110001110001110001010011111100111001110
    //---------------------------------------------------------
    // 1.1110111001100001111110001111110011010110011111111101
    //
    // 0 10000001000 1110111001100001111110001111110011010110011111111101
    // 0 10000001000 1110111001100001111110001111110011010110011111111101
    
    double x = 234.765411;
    double y = 754.0;
    System.out.println((x + y) == 988.765411);
    
    System.out.println(x);
    System.out.println(y);
    System.out.println(x + y);
    // d1 + d2와 달리 x + y의 계산 결과는 뒤에 극소수의 값이 붙지 않는다.
    // 234.765411 + 754.0 = 988.765411
    // 
    // 0 10000000110 1101010110000111111000111111001101011001111111110101 (234.765411)
    // 0 10000001000 0111100100000000000000000000000000000000000000000000 (754.0)
    //
    // 0.0111010101100001111110001111110011010110011111111101
    // 1.0111100100000000000000000000000000000000000000000000
    // ------------------------------------------------------
    // 1.1110111001100001111110001111110011010110011111111101
    //
    // 0 10000001000 1110111001100001111110001111110011010110011111111101
    //
    
    // IEEE 754의 변환 공식에 따라 발생되는 이런 문제를 
    // 실무 프로그래밍 할 때 해결하는 방법?
    //
    System.out.println((d1 + d2) == (x + y)); // false

    // 소수점 뒤에 붙은 극소수의 값을 무시하면 된다.
    // => JVM이 자동으로 처리하지 않는다.
    // => 다음과 같이 개발자가 직접 처리해야 한다.
    double EPSILON = 0.00001;
    System.out.println(Math.abs((d1 + d2) - (x + y)) < EPSILON);
  }
}

```

