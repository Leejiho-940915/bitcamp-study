## 24일차 수업내용(2021-07-29.목)

### 객체지향 프로그래밍을 떠받치는 주요 문법

### OOP란?

- Object
- Oriented
- Programming



#### OOP 객체지향 문법의 종류

- 추상클래스


- 인터 페이스
- 람다
- 중첩클래스
- 상속 (**inheritance**)
- 다형성 (**polymorphism**)
  - 다형적변수
  - 오버로딩
  - 오버라이딩
- 캡슐화 (**encapsulation**)
- 추상화 (**abstraction**)



#### 클래스 정의 = 추상화(abstraction)

- 새 데이터 타입 정의

  - 메모리 설계도
  - 데이터를 표현

- 기능(function = method) 묶음

  - 기능 = 업무

- 물리적인것이나 개념적인것을 데이터로 표현한것을 추상화라고 한다.

  - 물리적인 예)

    - 환자의 병명이나 치료받은부분을 데이터로 보관
    - 제품을 데이터로 보관

  - 개념적인 예)

    - 주문 조회 생성 취소 등을 데이터로 보관
    - 날짜를 데이터로 보관

    ​

#### 상속과 생성자ex05.h

##### 수퍼 클래스에 기본 생성자가 없을 때!

- 수퍼클래스에 값을 받는 생성자 가 있을 경우 서브클래스는 수퍼클래스에 있는 생성자와 그값을 제대로 호출해야 한다.


- 수퍼 클래스의 어떤 생성자를 호출할지 지정하지 않으면 컴파일러는 다음과 같이 수퍼 클래스의 기본 생성자를 호출하라는 명령을 붙인다.
-  //    super(); //만약 수퍼 클래스에 기본 생성자가 없으면 컴파일 오류가 발생한다!
- 개발자가 직접 수퍼 클래스에 있는 생성자를 호출하라!



#### 상속과 다중상속ex05.i

- **자바는 다중상속을 허용하지 않는다. 혼란을 가중시킨다.** **모호함**



#### 상속 기법

**Specialization(전문화)**

- 수퍼클래스를 상속 받아서 **서브클래스를 만드는 것!**

**Generalization(일반화)**

- 서브클래스들의 공통 코드를 추출하여 **수퍼클래스를 만드는 것!**



##### 기존 기능을 그역할에 맞게끔 재정의 = overriding



#### 상속 : specialization(전문화) ex05.j

- 수퍼클래스를 상속 받아 좀 더 특별한 역할을 하는 서브 클래스를 만드는 것!
- 기존 클래스에 기능을 덧붙여 특별한 클래스를 만드는 것
- 수퍼 클래스를 상속 받아 서브 클래스를 만드는 것을 "전문화(specialization)"라 부른다.



#### 상속 : generalization(일반화)

- 여려 클래스에 공통으로 나타나는 코드(필드, 메서드) 가 있다면 추출해서 수퍼클래스로 정의
- 서브클래스들의 공통 분모를 추출하여 수퍼클래스를 정의하는 방법을 말한다.



#### 결론

- 처음부터 객체지향 프로그래밍을 잘하려고 노력하지 말라.
- 리팩토링을 수행하면서 점점 더 유지보수가 좋은 oop 코드로 발전시키면 되는 것이다!



#### 상속 : 추상클래스(abstract class) ex05.m

- 클래스를 직접 사용하지 못하게 막고 단지 서브 클래스를 만들어 사용하도록 제한하는 문법이 "추상 클래스" 이다.


- 서브클래스에게 공통 기능을 상속해주는 목적으로 만든 클래스이다.
- 직접 사용하지 않는 클래스이다.
- 즉 개발자에게 이 클래스를 상속 받아 새 클래스를 만들어 쓰라는 의미다!
- 보통 '일반화(generalization)' 과정에서 생성되는 클래스를 추상 클래스로 만든다.
- generalization 과정에서 정의한 수퍼 클래스에 대해 직접 사용하지 못하도록 추상클래스로 선언한다.
- 문법:
  //      abstract class 클래스명 {...}



#### 상속 : 추상메서드(abstract method) ex05.n

- 서브 클래스에서 재정의할 메서드라면 굳이 수퍼 클래스에서 구현하지 말라!
- 또는 서브 클래에서 구현하도록 강제하고 싶다면 그때 해당 메서드를 추상 메서드로 선언한다.
- 추상메서드는 일반클래스가 못가진다.
  - 추상메서드를 만드려면 추상클래스만 만들수 있다.
-  public abstract void run(); 이라는 추상메서드를 만들었다.
  - 서브클래스는 run이라는 메서드를 꼭 구현해야한다. 안그럼 컴파일 오류!

##### 결론!

- 즉 추상클래스와 추상메서드는 수퍼 클래스 안에서만  만들수 있다.



#### 다형성 (**polymorphism**) ex06.a

클래스 계층도 (class hierarchy)

- 위에서 아래로는 가리킬수는  있어도 아래서 위로는 못가리킨다.
- 상위분류는 하위분류를 가리킨다.  하위분류는 상위분류의 특징을 다갖고있으니까 가리킬수있다.

##### 다형적 변수(polymorphic variables)

- 여러 인스턴스를 가리킬수 있다.
- 단! 규칙이 있다.
- 해당클래스와 하위클래스를 카리킬수 있다.

#### 다형적 변수와 형변환(type casting)

((원래인스턴스타입) 레퍼런스).멤버

- 잘못된 형변환을 할 경우,
  - 형변환(type casting)으로 컴파일러를 속일 수는 있지만, 실행할 때 오류가 발생할 것이다.
  - 속이지 말라!
  - 실행할 때 오류 발생! (runtime exception)

#### 다형적 변수의 활용

- 다형적 변수를 사용하게 되면 동일한 코드를 갖고 있는 메서드를 한 개의 메서드로 통합할 수 있다.
- 두 개의 클래스가 같은 조상을 가질 때는 다형적 변수를 활용하라!



#### 다형적 변수와 instanceof 연산자

 **instanceof 연산자?**

- 레퍼런스에 들어있는 주소가 특정 클래스의 인스턴스인지 검사한다.
- 또는 그 하위 클래스의 인스턴스인지 검사한다.

**getClass() ?**

- 레퍼런스가 가리키는 인스턴스의 실제 클래스 정보를 리턴한다.
-  == 연산자를 사용하여 특정 클래스의 인스턴스인지 좁혀서 검사할 수 있다.
- **레퍼런스변수명.getClass() == 클래스명.class**
  - 클래스명.class :  클래스 정보를 갖고 있는 스태틱 변수이다.



#### 메서드 오버로딩(overloading) - 문법 사용 전 ex06.b

##### 오버로딩(overloading)?

- 파라미터의 형식(타입과 개수)은 다르지만 같은 기능을 수행하는 메서드에 대해 같은 이름을 부여함으로써 프로그래밍의 일관성을 제공하기 위한 문법이다.
- 호출하는 메서드 이름은 같지만, 아규먼트의 타입이나 개수에 따라 호출되는 메서드가 결정된다.
- 파라미터 타입이나 개수, 순서는 다르지만 이름이 같은 메서드를 여러 개 만들 수 있는 문법
  - 파라미터의 형식은 다르지만 같은 기능을 수행하는 메서드에 대해
  - 같은 이름을 부여함으로써 프로그래밍의 일관성을 제공하기 위함.
- 주의!
  - 변수의 이름만 다른 메서드를 중복해서 만들 수 없다.
    - 이유?
    - 메서드를 찾을 때 파라미터 값의 타입으로 찾기 때문이다.
  - 리턴 타입만 다른 메서드를 중복해서 만들 수 없다.
    - 이유?
    - 메서드를 찾을 때 파라미터 값의 타입으로 찾기 때문이다.
- 오버로딩 규칙
  - 파라미터 타입이 달라야 한다.
  - 파라미터 개수가 달라야 한다.
  - 파라미터 이름이 다른 것으로는 메서드를 구분할 수 없다.
  - 접근 범위는 상관없다.

#### 오버라이딩(overriding) ?  ex06.c

- 상속받은메서드를 역할에따라 서브클래스 역할에 맞춰서 재정의한다.
- 상속 받은 메서드를 서브 클래스의 역할에 맞게 재정의하는 문법
- 상속 받은 메서드와 똑 같은 시그너처(메서드명, 파라미터 타입/개수/순서)로 메서드를 정의한다.
- 오버라이딩 메서드는 원래의 메서드 보다 접근 범위가 같거나 커야 한다.
  - 원래의 메서드 보다 접근 범위가 줄어들면 안된다.

