## 25일차 수업내용(2021-07-30.금)

#### 오버라이딩(overriding) - 오버라이딩 실수를 방지하는 방법 ex06.c0220

##### 오버라이딩 문법 검사

- 오버라이딩을 제대로 했는지 컴파일러에게 검사하도록 요청할 수 있다.
- 메서드 정의 앞에 @Override를 붙여라
  - @Override // <= 컴파일러야, 내가 상속받은 메서드를 재정의한다고 했는데, 혹시 실수는 없는지 검사해 줄래?
- 오버라이딩을 한다고 하면서 파라미터의 타입이나 개수, 순서를 달리해서 오버로딩이 되는 경우가 있기 때문에 이를 방지하기 위해 오버라이딩을 하는 메서드 앞에
- @Override 애노테이션을 붙임으로써 잘못 사용하는 경우를 방지할 수 있다.

##### @Override ?

- 애노테이션 문법이다.
- 컴파일러나 JVM에게 전달하는 특별한 주석이다.
- 개발자도 자신의 애노테이션을 정의하고 사용할 수 있다.



#### 오버라이딩(overriding) - private 메서드 오버라이딩? ex06.c.0310~0330

**멤버의 접근 범위**

- private : 같은 클래스
  - 현재 클래스
  - 예) private void m1() {}
- (default) : 같은 클래스 + 같은 패키지
  - 현재 클래스 + 같은 패키지 소속 클래스
  - void m2() {}
- protected : 같은 클래스 + 같은 패키지 + 서브 클래스
  - 현재 클래스 + 같은 패키지 소속 클래스 + 서브 클래스
  - protected void m3() {}
- public : 모두
  - 모두
  - public void m4() {}
- 오버라이딩 할 때(메서드를 재정의 할 때) : 원본 보다 접근 범위를 좁힐 수는 없다.
- 수퍼 클래스의 메서드를 자식 클래스가 재정의할 때 접근 범위를 확대할 순 있지만, 좁힐 수는 없다!

- 오버라이딩의 접근범위는 확대하는것은 가능 단 접근 범위보다 좁히는 것은 불가능!



#### 오버라이딩(overriding) - 오버라이딩과 super 키워드 ex06.c.0410~0430

**this 레퍼런스로 메서드를 호출하면,**

- 현재 클래스에서 메서드를 찾아 호출한다.
- 현재 클래스에 메서드가 없으면 수퍼 클래스에서 메서드를 찾는다.
- 메서드를 찾을 때까지 최상위 클래스까지 따라 올라간다.
- this에 실제 저장된 인스턴스의 클래스를 가리킨다.
- 실제 가리키는 인스턴스 클래스부터 메서드를 찾아 올라 간다.
  - new 라고명령했을때 레퍼런스변수에 인스턴스 변수 주소를 할당한곳부터
- this.메서드명();

**super 레퍼런스로 메서드를 호출하면,**

- 수퍼 클래스에서 메서드를 찾아 호출한다.
- 수퍼 클래스에 없으면 그 상위 클래스로 따라 올라간다.
- 오버라이딩 하기 전의 메서드를 호출하고 싶을 때 유용하다.
- 메서드가 소속된 관점에서  수퍼클래스를 가리킨다.
- 소속된 클래스 기준으로 수퍼 클래스에서 메서드를 찾아 올라간다.
  - 즉, 호출할때 메서드 안에 있는경우가 기준점이된다.
- super.메서드명();

this.필드,super.필드 도 메서드랑 같은경우다.

#### 오버라이딩(overriding) - 레퍼런스가 가리키는 필드 0510~

##### 레퍼런스 필드 형변환

- 레퍼런스를 형변환 하면 오버라이딩 하기 전, 해당 클래스의 인스턴스 변수를 가리킬 수 있다.
- 형변환 클래스에 존재하지 않는 필드는 가리킬 수 없다.
- 예) ((A3)obj1).age
- ((클래스이름)레퍼런스명.필드)

##### 레퍼런스 메서드 형변환

- 인스턴스 필드와 달리 메서드의 경우는 레퍼런스에 대한 형변환에 상관없이 실제 레퍼런스가 가리키는 클래스에서 메서드를 찾아 올라간다.

- 메서드의 형변환은 해당 인스턴스주소부터간다. 즉 형변환으로 작성해도 형변환이 안된다.



#### 오버라이딩(overriding) - 리턴 타입 0610~

- 메서드를 오버라이딩 할 때 리턴 타입으로 서브 클래스도 가능하다.
- 메서드를 오버라이딩 할 때 리턴 타입으로 수퍼 클래스는 불가능하다.
- 아래 예제를 통해 알 수 있다.

``` java
public class Exam0610 {

  static class Car {}
  static class Sedan extends Car {}
  static class Tico extends Sedan {}

  static class CarFactory {
    Car create() {
      return new Car();
    }
  }
  static class SedanFactory extends CarFactory {
    // 오버라이딩 메서드의 리턴 타입은 
    // 서브 클래스도 가능하다.
    @Override
    Sedan create() {
      return new Sedan();
    }
  }
  static class TicoFactory extends SedanFactory {
    // 오버라이딩 메서드의 리턴 타입은 
    // 서브 클래스도 가능하다.
    @Override
    Tico create() {
      return new Tico();
    }
  }
```



#### 다형적 변수와 오버라이딩 - 레퍼런스와 메서드 호출ex06.d

레퍼런스가 하위 클래스의 인스턴스를 가리킬 때

- 레퍼런스를 통해 호출하는 메서드는 레퍼런스가 실제 가리키는 하위 클래스에서 찾아 올라 간다.

- 다형적 변수의 사용법에 따라, super 클래스 레퍼런스로 하위 클래스의 인스턴스를 가리킨다.
- 오버라이딩 메서드 호출 규칙에 따라, 레퍼런스가 실제 가리키는 객체의 클래스부터 메서드를 찾아 올라간다.

