## 25일차 수업내용(2021-07-30.금)

#### 오버라이딩(overriding) - 오버라이딩 실수를 방지하는 방법 ex06.c0220

##### 오버라이딩 문법 검사

- 오버라이딩을 제대로 했는지 컴파일러에게 검사하도록 요청할 수 있다.
- 메서드 정의 앞에 @Override를 붙여라
  - @Override // <= 컴파일러야, 내가 상속받은 메서드를 재정의한다고 했는데, 혹시 실수는 없는지 검사해 줄래?
- 오버라이딩을 한다고 하면서 파라미터의 타입이나 개수, 순서를 달리해서 오버로딩이 되는 경우가 있기 때문에 이를 방지하기 위해 오버라이딩을 하는 메서드 앞에
- @Override 애노테이션을 붙임으로써 잘못 사용하는 경우를 방지할 수 있다.

##### @Override ?

- 애노테이션 문법이다.
- 컴파일러나 JVM에게 전달하는 특별한 주석이다.
- 개발자도 자신의 애노테이션을 정의하고 사용할 수 있다.



#### 오버라이딩(overriding) - private 메서드 오버라이딩? ex06.c.0310~0330

**멤버의 접근 범위**

- private : 같은 클래스
  - 현재 클래스
  - 예) private void m1() {}
- (default) : 같은 클래스 + 같은 패키지
  - 현재 클래스 + 같은 패키지 소속 클래스
  - void m2() {}
- protected : 같은 클래스 + 같은 패키지 + 서브 클래스
  - 현재 클래스 + 같은 패키지 소속 클래스 + 서브 클래스
  - protected void m3() {}
- public : 모두
  - 모두
  - public void m4() {}
- 오버라이딩 할 때(메서드를 재정의 할 때) : 원본 보다 접근 범위를 좁힐 수는 없다.
- 수퍼 클래스의 메서드를 자식 클래스가 재정의할 때 접근 범위를 확대할 순 있지만, 좁힐 수는 없다!

- 오버라이딩의 접근범위는 확대하는것은 가능 단 접근 범위보다 좁히는 것은 불가능!



#### 오버라이딩(overriding) - 오버라이딩과 super 키워드 ex06.c.0410~0430

**this 레퍼런스로 메서드를 호출하면,**

- 현재 클래스에서 메서드를 찾아 호출한다.
- 현재 클래스에 메서드가 없으면 수퍼 클래스에서 메서드를 찾는다.
- 메서드를 찾을 때까지 최상위 클래스까지 따라 올라간다.
- this에 실제 저장된 인스턴스의 클래스를 가리킨다.
- 실제 가리키는 인스턴스 클래스부터 메서드를 찾아 올라 간다.
  - new 라고명령했을때 레퍼런스변수에 인스턴스 변수 주소를 할당한곳부터
- this.메서드명();

**super 레퍼런스로 메서드를 호출하면,**

- 수퍼 클래스에서 메서드를 찾아 호출한다.
- 수퍼 클래스에 없으면 그 상위 클래스로 따라 올라간다.
- 오버라이딩 하기 전의 메서드를 호출하고 싶을 때 유용하다.
- 메서드가 소속된 관점에서  수퍼클래스를 가리킨다.
- 소속된 클래스 기준으로 수퍼 클래스에서 메서드를 찾아 올라간다.
  - 즉, 호출할때 메서드 안에 있는경우가 기준점이된다.
- super.메서드명();



메서드의 형변환은 해당 인스턴스주소부터간다. 즉 형변환이안된다.



