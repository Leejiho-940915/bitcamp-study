## 25일차 수업내용(2021-07-30.금)

#### 오버라이딩(overriding) - 오버라이딩 실수를 방지하는 방법 ex06.c0220

##### 오버라이딩 문법 검사

- 오버라이딩을 제대로 했는지 컴파일러에게 검사하도록 요청할 수 있다.
- 메서드 정의 앞에 @Override를 붙여라
  - @Override // <= 컴파일러야, 내가 상속받은 메서드를 재정의한다고 했는데, 혹시 실수는 없는지 검사해 줄래?
- 오버라이딩을 한다고 하면서 파라미터의 타입이나 개수, 순서를 달리해서 오버로딩이 되는 경우가 있기 때문에 이를 방지하기 위해 오버라이딩을 하는 메서드 앞에
- @Override 애노테이션을 붙임으로써 잘못 사용하는 경우를 방지할 수 있다.

##### @Override ?

- 애노테이션 문법이다.
- 컴파일러나 JVM에게 전달하는 특별한 주석이다.
- 개발자도 자신의 애노테이션을 정의하고 사용할 수 있다.



#### 오버라이딩(overriding) - private 메서드 오버라이딩? ex06.c.0310~0330

**멤버의 접근 범위**

- private : 같은 클래스
  - 현재 클래스
  - 예) private void m1() {}
- (default) : 같은 클래스 + 같은 패키지
  - 현재 클래스 + 같은 패키지 소속 클래스
  - void m2() {}
- protected : 같은 클래스 + 같은 패키지 + 서브 클래스
  - 현재 클래스 + 같은 패키지 소속 클래스 + 서브 클래스
  - protected void m3() {}
- public : 모두
  - 모두
  - public void m4() {}
- 오버라이딩 할 때(메서드를 재정의 할 때) : 원본 보다 접근 범위를 좁힐 수는 없다.
- 수퍼 클래스의 메서드를 자식 클래스가 재정의할 때 접근 범위를 확대할 순 있지만, 좁힐 수는 없다!

- 오버라이딩의 접근범위는 확대하는것은 가능 단 접근 범위보다 좁히는 것은 불가능!



#### 오버라이딩(overriding) - 오버라이딩과 super 키워드 ex06.c.0410~0430

**this 레퍼런스로 메서드를 호출하면,**

- 현재 클래스에서 메서드를 찾아 호출한다.
- 현재 클래스에 메서드가 없으면 수퍼 클래스에서 메서드를 찾는다.
- 메서드를 찾을 때까지 최상위 클래스까지 따라 올라간다.
- this에 실제 저장된 인스턴스의 클래스를 가리킨다.
- 실제 가리키는 인스턴스 클래스부터 메서드를 찾아 올라 간다.
  - new 라고명령했을때 레퍼런스변수에 인스턴스 변수 주소를 할당한곳부터
- this.메서드명();

**super 레퍼런스로 메서드를 호출하면,**

- 수퍼 클래스에서 메서드를 찾아 호출한다.
- 수퍼 클래스에 없으면 그 상위 클래스로 따라 올라간다.
- 오버라이딩 하기 전의 메서드를 호출하고 싶을 때 유용하다.
- 메서드가 소속된 관점에서  수퍼클래스를 가리킨다.
- 소속된 클래스 기준으로 수퍼 클래스에서 메서드를 찾아 올라간다.
  - 즉, 호출할때 메서드 안에 있는경우가 기준점이된다.
- super.메서드명();

this.필드,super.필드 도 메서드랑 같은경우다.

#### 오버라이딩(overriding) - 레퍼런스가 가리키는 필드 0510~

##### 레퍼런스 필드 형변환

- 레퍼런스를 형변환 하면 오버라이딩 하기 전, 해당 클래스의 인스턴스 변수를 가리킬 수 있다.
- 형변환 클래스에 존재하지 않는 필드는 가리킬 수 없다.
- 예) ((A3)obj1).age
- ((클래스이름)레퍼런스명.필드)

##### 레퍼런스 메서드 형변환

- 인스턴스 필드와 달리 메서드의 경우는 레퍼런스에 대한 형변환에 상관없이 실제 레퍼런스가 가리키는 클래스에서 메서드를 찾아 올라간다.

- 메서드의 형변환은 해당 인스턴스주소부터간다. 즉 형변환으로 작성해도 형변환이 안된다.



#### 오버라이딩(overriding) - 리턴 타입 0610~

- 메서드를 오버라이딩 할 때 리턴 타입으로 서브 클래스도 가능하다.
- 메서드를 오버라이딩 할 때 리턴 타입으로 수퍼 클래스는 불가능하다.
- 아래 예제를 통해 알 수 있다.

``` java
public class Exam0610 {

  static class Car {}
  static class Sedan extends Car {}
  static class Tico extends Sedan {}

  static class CarFactory {
    Car create() {
      return new Car();
    }
  }
  static class SedanFactory extends CarFactory {
    // 오버라이딩 메서드의 리턴 타입은 
    // 서브 클래스도 가능하다.
    @Override
    Sedan create() {
      return new Sedan();
    }
  }
  static class TicoFactory extends SedanFactory {
    // 오버라이딩 메서드의 리턴 타입은 
    // 서브 클래스도 가능하다.
    @Override
    Tico create() {
      return new Tico();
    }
  }
```



#### 다형적 변수와 오버라이딩 - 레퍼런스와 메서드 호출ex06.d

레퍼런스가 하위 클래스의 인스턴스를 가리킬 때

- 레퍼런스를 통해 호출하는 메서드는 레퍼런스가 실제 가리키는 하위 클래스에서 찾아 올라 간다.

- 다형적 변수의 사용법에 따라, super 클래스 레퍼런스로 하위 클래스의 인스턴스를 가리킨다.
- 오버라이딩 메서드 호출 규칙에 따라, 레퍼런스가 실제 가리키는 객체의 클래스부터 메서드를 찾아 올라간다.

#### final 사용법 ex06.e

- 예) final class {}
  - 클래스에 파이널을붙이면 상속불가
  - 클래스에 final 을 붙이면 이 클래스의 서브 클래스를 만들 수 없다.
  - 서브 클래스를 생성을 방지하여 기존 클래스를 대체하지 못하도록 할 때 사용한다.

- 예) final void m1() {}
  - 메서드에 final 을 붙이면 서브 클래스에서 오버라이딩 할 수 없다.
  - 서브 클래스에서 변경하면 안되는 메서드인 경우에 사용한다.
  - 예)
    - 보안에 관련된 일을 하는 메서드
    - 템플릿 메서드 디자인 패턴에서처럼 전체적인 작업 흐름을 정의한 메서드의 경우 서브 클래스의 오버라이딩을 막는 것이 좋다.

- 예)  final int v1 = 100;
  - 변수 초기화 문장으로 값을 초기화시킬 수 있다.
  - 필드에 파이널을 붙이면 한번만 값을 초기화 시킬 수 있다.상수 필드가 된다.
  - 변수 초기화 문장은 컴파일 될 때 생성자로 복사되기 때문이다.
  - 초기화 문장에서 값을 설정했으면, 생성자에서 다시 값을 설정할 수 없다.

- 로컬 변수에 final을 붙이면 값을 변경할 수 없는 상수로 사용된다.

- final 사용법: 파라미터
  - 파라미터는 메서드가 호출될 때 외부의 값을 받는 용도의 변수다.
  - 메서드 안에서 파라미터 값을 임의로 변경하게 되면 처음 받은 파라미터 값을 사용하지 못하는 상황이 발생한다.
  - 그래서 이런 상황을 피하고자, 보통 실무에서 파라미터를 final로 선언한다.

#### 필드(field), 세터(setter)/게터(getter) , 프로퍼티(property)

##### 캡슐화 문법?

- 자바는 필드나 메서드의 외부 접근 범위를 조정하는 문법을 제공한다.
  - 그 문법을 '캡슐화(encapsulation)'라 부른다.
- private 을 쓴다면 해당 필드나 메서드를 외부의 접근으로부터 막을 수 있다.

누군가 프로퍼티명을 물어본다면 프로퍼티명은 

##### 게터(getter)

- 외부에서 이 값들을 조회할 수 있는 방법/수단(method)은 제공해야 한다.
- 보통 이렇게 필드의 값을 조회하는 용도로 사용하기 위해 메서드를 만들경우
- 메서드의 용도를 이해하기 쉽도록 getXxx() 형태로 이름을 짓는다.
  -  get필드명() {...}
- 메서드의 이름이 get 으로 시작한다고 해서 "게터(getter)"라고 부른다.
- 그리고 이런 getter는 공개 모드로 설정한다.

##### 세터(setter)

- 보통 필드의 값을 설정하는 메서드는 set필드명()으로 이름을 짓는다.
- 이런 메서드를 "세터(setter)"라 부른다.
- 외부에서 호출할 수 있도록 공개 모드로 설정한다.

- 필드를 비공개로 막으면 값을 조회할 수 없기 때문에 getter를 추가해야 한다.
- 공개할 필요가 없는 메서드는 private으로 막아라.
- 보통 private 으로 막는 메서드는 해당 클래스 내부에서만 사용되는 메서드이다.

