## 33일차 수업내용(2021-08-11.수)

##### basic.ex02.0210~

` Wrapper 클래스 - 종류 `

래퍼 클래스의 주요 용도:

- primitive data type의 값을 객체로 주고 받을 때 사용한다.
- primitive data type의 값을 객체에 담아 전달하고 싶다면 언제든 wrapper 클래스의 인스턴스를 만들면 된다.
- Wrapper 클래스의 인스턴스를 생성할 때는 생성자 대신 클래스 메서드를 사용하라.
  - Byte b2 = Byte.valueOf((byte)100);
  - Short s2 = Short.valueOf((short)20000);
  - Integer i2 = Integer.valueOf(3000000);
  - Long l2 = Long.valueOf(60000000000L);
  - Float f2 = Float.valueOf(3.14f);
  - Double d2 = Double.valueOf(3.14159);
  - Boolean bool2 = Boolean.valueOf(true);
  - Character c2 = Character.valueOf((char)0x41);

##### ` Wrapper 클래스 - 오토박싱(auto-boxing)/오토언박싱(auto-unboxing) `

` 오토박싱(auto-boxing) `

- wrapper 객체 자동 생성
- Ineteger obj = 100; 이라고 했을때 
  - 컴파일러는 다음 문장으로 변환 시켜서 wrapper 객체의 주소가 i에 저장됨
  - 100이 obj에 저장되는게 아니다 x
  - Integer.valueOf(100)

` 오토언박싱(auto-unboxing) `

- wrapper 객체에 들어있는 값을 자동으로 꺼낸다.
- Ineteger obj = Integer.valueOf(100);  라고 했을때
  - int i =obj;  가 가능하다.
    - 컴파일러는 다음 문장으로 변환
    - obj.intValue() 이문장이 wrapper 객체에 보관된 int 값을 꺼내 i에 저장한다.

` auto-boxing 으로 Wrapper 객체를 생성할 경우 `

- 정수 값이 -128 ~ 127 범위일 경우
  - 자주 사용되는 수이기 때문에 String 리터럴처럼 상수 풀에 Integer 객체를 생성한다.
  - 메모리를 효율적으로 사용하기 위해 같은 값을 가지는 Integer 객체가 여러 개 존재하지 않게 한다.
  - 그래서 가능한 이 방법을 사용해야 한다.
- -128 ~ 127 범위를 넘어가는 경우 무조건 새 객체를 만든다.
- 이유?
  - 다루는 숫자가 너무 많기 때문에 무조건 상수 풀에 만들기에는 오히려 메모리 낭비가 심해지기 때문이다.
  - 상수풀에 생성된 객체는 JVM이 종료되기 전까지 유지된다.
  - 즉 가비지가 되지 않는다.
  - 그러나 heap에 생성된 객체는 주소를 잃어 버리면 가비지가 되기 때문에 메모리를 좀 더 효율적으로 사용할 수 있다.
- 결론!
  - wrapper 객체의 값을 비교할 때 == 연산자를 사용하지 말라!
  - -128 ~ 127 범위 내의 값이라면 == 연산자를 사용하여 비교할 수도 있지만, 매번 비교할 때 마다 범위의 유효성을 생각하는 것이 번거롭다.
  - 그냥 equals() 메서드를 사용하여 값을 비교하라!
  - 더 좋은 방법은 auto-unboxing 하여 primitive type 의 값으로 바꾼후에 ==연산자로 비교하라.